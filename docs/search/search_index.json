{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chilo","text":"<p>Chilo, short for chilorhinophis (meaning two headed snake), is a lightweight, form-meets-function, opinionated (yet highly configurable) api framework.</p>"},{"location":"#benefits","title":"Benefits","text":"<ul> <li>No route definitions needed; route based on your directory structure</li> <li>Built-in OpenAPI request and response validation</li> <li>Ease of use with gunicorn</li> <li>Generate OpenAPI spec from code base</li> <li>Infinitely customizable with middleware extensions</li> </ul>"},{"location":"#philosophy","title":"Philosophy","text":"<p>The Chilo philosophy is to provide a dry, configurable, declarative framework, which encourages Happy Path Programming (HPP).</p> <p>Happy Path Programming is an idea in which inputs are all validated before operated on. This ensures code follows the happy path without the need for mid-level, nested exceptions and all the nasty exception handling that comes with that. The library uses layers of customizable middleware options to allow a developer to easily dictate what constitutes a valid input, without nested conditionals, try/catch blocks or other coding blocks which distract from the happy path which covers the majority of the source code's intended operation.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.8 or higher; download and install Python</li> <li>Access to public python registry</li> </ul> Shell <pre><code>$ pip install chilo_api\n# pipenv install chilo_api\n# poetry add chilo_api\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-create-mainpy","title":"1. Create <code>main.py</code>","text":"<pre><code>from chilo_api import Chilo\n\n\napi = Chilo(\n    base_path='/',\n    handlers='api/handlers',\n)\n</code></pre>"},{"location":"#2-create-first-handler","title":"2. Create First Handler","text":"Tip <p>Remember your directory stucture dictates your routes; <code>__init__.py</code> will default to the index of that route if it ends in slash</p> <p><code>{PWD}/api/handlers/__init__.py</code> <pre><code>def get(request, response):\n    response.body = {'hello': 'world'}\n    return response\n</code></pre></p>"},{"location":"#3-run-your-api","title":"3. Run your API","text":"<pre><code>python -m chilo_api serve --api=main --reload=true\n</code></pre>"},{"location":"#4-checkout-your-api","title":"4. Checkout your API","text":"<p>http://127.0.0.1:3000/</p>"},{"location":"#5-validate-your-endpoint-optional","title":"5. Validate Your Endpoint (optional)","text":"<pre><code>from chilo_api import requirements\n\n\n@requirements(required_params=['greeting'])\ndef get(request, response):\n    response.body = {'hello': request.query_params['greeting']}\n    return response\n</code></pre>"},{"location":"#4-checkout-your-api-again","title":"4. Checkout your API (again)","text":"<p>http://127.0.0.1:3000/?greeting=developer</p>"},{"location":"guides/endpoint/","title":"Building an Endpoint","text":"<p>Each endpoint is meant to be treated as a separate module within the API.Every endpoint file should contain a function which matches an  HTTP method in lower case.  Most common are <code>post</code>, <code>get</code>, <code>put</code>, <code>patch</code>, <code>delete</code>; this library does support custom methods,  if you so choose. As long as the method of the request matches the function name, it will work.</p> <p>Each method within the endpoint file can have individual validation requirements. These requirements allow you to test  all structural points of the request, with the ability to use JSONSchema and custom middleware to further extend the  validation options as well as add additional logic to verify data beyond structural and data-type requirements.</p> <pre><code># example for endpoint file: api/handler/grower.py\nfrom chilo_api import requirements\n\n\ndef filter_grower(request, response, requirements):\n    if 'GET' in response.raw['message']:\n      logger.log(log=response.raw)\n\n@requirements(\n    required_query=['requester_id'],\n    available_query=['grower_id', 'grower_email'],\n    required_body='v1-grower-post-request', # refence to openapi.yml\n    request_class=Grower,\n    before=log_grower,\n    after=filter_grower,\n    auth_required=True\n)\ndef post(request, response):\n    response.body = {'message': 'GET called', 'request_query_params': request.query_params}\n    return response\n</code></pre>"},{"location":"guides/openapi/","title":"Generating An OpenAPI","text":"<p>You can generate a openapi yaml and/or json doc from your existing codebase. This feature can also add to existing openapi docs and/or overwrite incorrect documentation.</p>"},{"location":"guides/openapi/#command","title":"command","text":"<pre><code>python -m chilo generate-openapi --api=api --output=tests/outputs --format=yml,json --delete\n</code></pre>"},{"location":"guides/openapi/#output","title":"output","text":"<pre><code>STARTED\ngenerating openapi docs...\nvalidating arguments received...\narguments validated...\nscanning handlers: tests/mocks/apigateway/openapi/**/*.py...\nimporting handler endpoint modules...\ndeleting paths and methods not found in code base\nwriting openapi doc to requested directory: tests/outputs\nCOMPLETED\n</code></pre>"},{"location":"guides/openapi/#options","title":"options","text":"<pre><code>--handlers (-l): directory or pattern location of your handlers\n--base (-b): (optional) base path of the api url; default='/'\n--output (-o): (optional) directory location to save openapi file; defaults handlers directory location\n--format (-f): (optional) comma deliminted format options (yml, json)\n--delete (-d): (optional) will delete routes and methods in existing openapi doc not found in code base\n</code></pre>"},{"location":"guides/router/","title":"Configuring the Router","text":"<p>Chilo uses your directory structure as your api routes. This means you don't have to worry about manually setting routes or decorating functions, which might overlap, during your development process. You just need create the handler file in the desired location.</p> <pre><code>~~ Directory ~~                         ~~ Route ~~\n==========================================================================\n\ud83d\udce6api/                                  |          \n\u2502---\ud83d\udcc2handlers                          |           \n    \u2502---stores.py                       | /stores    \n    \u2502---\ud83d\udcc2item                          |\n        \u2502---\ud83d\udcdc__init__.py               | /item\n        \u2502---\ud83d\udcdc_item_id.py               | /item/{item_id}\n    \u2502---\ud83d\udcc2users                         |\n        \u2502---\ud83d\udcdc__init__.py               | /users\n        \u2502---\ud83d\udcc2_user_id                  |\n            \u2502---\ud83d\udcdc__init__.py           | /users/{user_id}\n            \u2502---\ud83d\udcc2pref                  |\n                \u2502---\ud83d\udcdc__init__.py       | /users/{user_id}/pref\n                \u2502---\ud83d\udcdc_pref_id.py       | /users/{user_id}/pref/{pref_id}\n</code></pre>"},{"location":"reference/endpoint/","title":"Endpoint Reference","text":""},{"location":"reference/endpoint/#configuration-options","title":"Configuration Options","text":"requirement type description <code>required_headers</code> array every header in this array must be in the headers of request <code>available_headers</code> array only headers in this array will be allowed in the request <code>required_query</code> array every item in the array is a required query string parameter <code>available_query</code> array only items in this array are allowed in the request <code>required_route</code> str when using parameters, this is the required parameters <code>required_body</code> str references a JSschema component in your <code>schema</code> <code>required_response</code> str references a JSschema component in your <code>schema</code> to validate response <code>required_auth</code> bool will trigger <code>with_auth</code> function defined in the router config <code>before</code> func a custom function to be ran before your method function <code>after</code> func a custom function to be ran after your method function <code>request_class</code> class a custom class that will be passed instead of the request obj <code>timeout</code> bool timeout set for that method, not including before/after calls <code>summary</code> str summary for use with openapi doc generation <code>deprecated</code> bool deprecated for use with openapi doc generation [<code>custom-requirement</code>] any see bottom of section"},{"location":"reference/endpoint/#required_headers","title":"<code>required_headers</code>","text":"Info <p>Headers are case-sensitive, make sure your casing matches your expectations.</p> <pre><code>@requirements(\n    required_headers=['x-api-key']\n)\ndef post(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#available_headers","title":"<code>available_headers</code>","text":"Warning <p>This is not recommended for frequent use as it raises errors for every header which does not conform to the array provided. Many browsers, http tools, and libraries will automatically add headers to request, unbeknownst to the user. By using this setting, you will force every user of the endpoint to take extra care with the headers provided and may result in poor API consumer experience.</p> <pre><code>@requirements(\n    available_headers=['x-api-key', 'x-on-behalf-of']\n)\ndef post(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#required_query","title":"<code>required_query</code>","text":"<pre><code>@requirements(\n    required_query=['grower_id']\n)\ndef get(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#available_query","title":"<code>available_query</code>","text":"Info <p><code>available_query</code> entries do NOT need to include entries already defined in the <code>required_query</code>; what is required,is assumed to be available.</p> <pre><code>@requirements(\n    available_query=['grower_email']\n)\ndef get(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#required_route","title":"<code>required_route</code>","text":"Warning <p>This is required if you are using dynamic routing (ex. <code>_id.py</code>) with path parameters. The router will provide a path values in <code>request.path_params</code></p> <pre><code>@requirements(\n    required_route='grower/{id}'\n)\ndef get(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#required_body","title":"<code>required_body</code>","text":"Info <p>This is referencing a <code>components.schemas</code> section of your openapi.yml file defined in the <code>schema</code> value in your router config, but you can also pass in a <code>json schema</code> in the form of a <code>dict</code>.</p> <pre><code>@requirements(\n    required_body='v1-grower-post-request'\n)\ndef post(request, response):\n    pass\n\n\n@requirements(\n    required_body={\n        'type': 'object',\n        'required': ['grower_id'],\n        'additionalProperties': False,\n        'properties': {\n            'grower_id': {\n                'type': 'string'\n            },\n            'body': {\n                'type': 'object'\n            },\n            'dict': {\n                'type': 'boolean'\n            }\n        }\n    }\n)\ndef patch(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#required_response","title":"<code>required_response</code>","text":"Info <p>This is referencing a <code>components.schemas</code> section of your openapi.yml file defined in the <code>schema</code> value in your router config, but you can also pass in a <code>json schema</code> in the form of a <code>dict</code>.</p> <pre><code>@requirements(\n    required_response='v1-grower-post-response'\n)\ndef post(request, response):\n    pass\n\n\n@requirements(\n    required_response={\n        'type': 'object',\n        'required': ['grower_id'],\n        'additionalProperties': False,\n        'properties': {\n            'grower_id': {\n                'type': 'string'\n            },\n            'body': {\n                'type': 'object'\n            },\n            'dict': {\n                'type': 'boolean'\n            }\n        }\n    }\n)\ndef patch(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#auth_required","title":"<code>auth_required</code>","text":"Info <p>This will trigger the function you provided in the router config under the <code>with_auth</code> configuration</p> <pre><code>@requirements(\n    auth_required=True\n)\ndef delete(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#before","title":"<code>before</code>","text":"<pre><code>def before_func(request, response, requirements):\n    print(request)\n    print(response)\n    print(requirements)\n\n\n@requirements(\n    before=before_func\n)\ndef post(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#after","title":"<code>after</code>","text":"<pre><code>def after_func(request, response, requirements):\n    print(request)\n    print(response)\n    print(requirements)\n\n\n@requirements(\n    before=after_func\n)\ndef post(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#request_class","title":"<code>request_class</code>","text":"Info <p>Instead of getting a <code>request</code> and <code>response</code> as arguments passed to your API function, you will get an instance </p> <p>of the class you provided here</p> <pre><code>class Grower:\n    def __init__(self, request):\n        for k, v in request.body.items():\n            setattr(self, k, v)\n\n@requirements(\n    request_class=Grower\n)\ndef post(grower, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#timeout","title":"<code>timeout</code>","text":"Info <p>This will override the timeout set in the main router configuration and only counts time for this request, not including before/after functions</p> <pre><code>@requirements(timeout=20)\ndef post(grower, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#custom-requirements","title":"custom requirements","text":"Info <p>You can add as many custom requirements as you want, with any variable type you want, and they will be passed to  your <code>before_all</code>, <code>before</code>, <code>after_all</code>, <code>after</code> and <code>with_auth</code> middleware defined functions.</p> <pre><code>@requirements(\n    custom={'whatever': ('you', 'want')}\n)\ndef put(request, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#summary","title":"<code>summary</code>","text":"Info <p>This is ONLY useful with openapi doc generation</p> <pre><code>@requirements(summary='some summary about what this endpoint does')\ndef post(grower, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#deprecated","title":"<code>deprecated</code>","text":"Info <p>This is ONLY useful with openapi doc generation</p> <pre><code>@requirements(deprecated=True)\ndef post(grower, response):\n    pass\n</code></pre>"},{"location":"reference/endpoint/#example-code","title":"Example Code","text":"<pre><code># example for endpoint file: api/handler/grower.py\nfrom chilo_api import requirements\nfrom chilo_api import logger\n\nfrom api.logic.grower import Grower\nfrom api.logic.middlware import log_grower, filter_grower\n\n\n# example after function\ndef filter_grower(request, response, requirements):\n    if 'GET' in response.raw['message']:\n      logger.log(log=response.raw)\n\n@requirements(\n    required_query=['requester_id'],\n    available_query=['grower_id', 'grower_email'],\n    request_class=Grower,\n    after=filter_grower,\n    auth_required=True\n)\ndef get(request, response):\n    response.body = {'message': 'GET called', 'request_query_params': request.query_params}\n    return response\n\n\n# example before function\ndef log_grower(request, response, requirements):\n    logger.log(log=request.body['grower_id'])\n\n@requirements(\n    required_body='v1-grower-post-request',\n    before=log_grower,\n    auth_required=True\n)\ndef post(request, response):\n    response.body = {'message': 'POST called', 'request_body': request.body}\n    return response\n\n\n@requirements(\n    required_headers=['x-api-key', 'x-correlation-id']\n    required_route='grower/{grower_id}'\n    auth_required=True\n    required_body={\n        'type': 'object',\n        'required': ['grower_id'],\n        'additionalProperties': False,\n        'properties': {\n            'grower_id': {\n                'type': 'string'\n            },\n            'body': {\n                'type': 'object'\n            },\n            'dict': {\n                'type': 'boolean'\n            }\n        }\n    }\n)\ndef patch(request, response):\n    response.body = {'message': 'PATCH called', 'request_body': request.body}\n    return response\n\n\n@requirements(timeout=20) # this will override timeout set in router.py\ndef put(request, response):\n    response.body = {'message': 'PUT called'}\n    return response\n\n\n# requirements is not required\ndef delete(request, response):\n    response.body = {'message': 'DELETE called'}\n    return response\n</code></pre>"},{"location":"reference/logger/","title":"Logger Reference","text":"<p>Below is an example of how to use the logger:</p>"},{"location":"reference/logger/#basic-usage","title":"Basic Usage","text":"<pre><code>import os\n\nfrom chilo_api import logger\n\nlogger.log(level='INFO', log='some log') # level=INFO|DEBUG|WARN|ERROR\n</code></pre>"},{"location":"reference/logger/#decorator-usage","title":"Decorator Usage","text":"<p>The Chilo logger also comes packaged as an easy to use log decorator that can decorate any method or function and even apply log conditions so you can control when exactly something is logged.</p> <pre><code>from chilo_api import log\n\n@log()\ndef example_simple(arg1, arg2, **kwargs):\n    return {'args': [arg1, arg2], 'kwargs': kwargs}\n\n@log(level='INFO')\ndef example_level(arg1, arg2, **kwargs):\n    return {'args': [arg1, arg2], 'kwargs': kwargs}\n\n@log(level='INFO', condition=some_log_condition)\ndef example_condition(arg1, arg2, **kwargs):\n    return {'args': [arg1, arg2], 'kwargs': kwargs}\n\ndef some_log_condition(*args, **kwargs):\n    if args[0] == 1:\n        return True\n    return False\n</code></pre>"},{"location":"reference/request/","title":"Request Reference","text":"<p>By default, every endpoint function will receive an instance of the <code>Request</code> class (aka <code>request</code>) as the first  argument of their function. This <code>request</code> has a lot of properties which will do common things automatically, but  still allows the developer to override those operations if they deem necessary. Below is a list and examples of all  the properties of the <code>request</code>:</p>"},{"location":"reference/request/#request-properties","title":"Request Properties","text":"property type mutable description <code>method</code> str no the http method of the request <code>cookies</code> list no the cookies of the request <code>protocol</code> str no the protocol of the request <code>content_type</code> str no the content_type of the request body <code>host_url</code> str no the host_url of the request was sent to <code>domain</code> str no the domain of the request was sent to <code>stage</code> str no the stage the lambda was deployed to <code>resource</code> str no the AWS resource being invoked <code>authorizer</code> object no if using a customized authorizer, the authorizer object <code>headers</code> object no the headers of the request <code>params</code> object no combination of query string and path params in one object <code>query_params</code> object no query string parameters from the request <code>path_params</code> object no the path parameters of the request <code>route</code> str no the requested route with placeholders of params <code>path</code> str no the raw requested path with actual param values <code>json</code> object no the body of the request, converted from json string in object <code>xml</code> object no the body of the request, converted from xml string in object <code>graphql</code> str no the body of the graphql request as a string <code>body</code> any no the body of the request, converted to based on data type <code>raw</code> any no the raw body of the request no conversion <code>context</code> object yes mutable request context to assigned and pass around"},{"location":"reference/request/#requestcookies","title":"<code>request.cookies</code>","text":"<pre><code>print(request.cookies)\n\n# output: \n['some-cookie']\n</code></pre>"},{"location":"reference/request/#requestprotocol","title":"<code>request.protocol</code>","text":"<pre><code>print(request.protocol)\n\n# output: \n'https'\n</code></pre>"},{"location":"reference/request/#requestcontent_type","title":"<code>request.content_type</code>","text":"<pre><code>print(request.content_type)\n\n# output: \n'application/json'\n</code></pre>"},{"location":"reference/request/#requesthost_url","title":"<code>request.host_url</code>","text":"<pre><code>print(request.host_url)\n\n# output: \n'https://api.are-great.com'\n</code></pre>"},{"location":"reference/request/#requestdomain","title":"<code>request.domain</code>","text":"<pre><code>print(request.domain)\n\n# output: \n'api.are-great.com'\n</code></pre>"},{"location":"reference/request/#requeststage","title":"<code>request.stage</code>","text":"<pre><code>print(request.stage)\n\n# output: \n'prod'\n</code></pre>"},{"location":"reference/request/#requestmethod","title":"<code>request.method</code>","text":"<pre><code>print(request.method)\n\n# output: \n'get'\n</code></pre>"},{"location":"reference/request/#requestresource","title":"<code>request.resource</code>","text":"<pre><code>print(request.resource)\n\n# output: \n'/{proxy+}'\n</code></pre>"},{"location":"reference/request/#requestauthorizer","title":"<code>request.authorizer</code>","text":"Tip <p>This is only useful if you are using an external authorizer with your lambda.</p> <pre><code>print(request.authorizer)\n\n# output:\n{\n    'apiKey': 'SOME KEY',\n    'userId': 'x-1-3-4',\n    'correlationId': 'abc12312',\n    'principalId': '9de3f415a97e410386dbef146e88744e',\n    'integrationLatency': 572\n}\n</code></pre>"},{"location":"reference/request/#requestheaders","title":"<code>request.headers</code>","text":"<pre><code>print(request.headers)\n\n# output:\n{\n    'x-api-key': 'SOME-KEY',\n    'content-type': 'application/json'\n}\n</code></pre>"},{"location":"reference/request/#requestparams","title":"<code>request.params</code>","text":"Info <p>This combines both path parameters and query string parameters, nested in one object.</p> <pre><code>print(request.params)\n\n# output:\n{\n    'query': {\n        'name': 'me'\n    },\n    'path': {\n        'id': 1\n    }\n}\n</code></pre>"},{"location":"reference/request/#requestquery_params","title":"<code>request.query_params</code>","text":"<pre><code>print(request.query_params)\n\n# output:\n{\n     'name': 'me'\n}\n</code></pre>"},{"location":"reference/request/#requestpath_params","title":"<code>request.path_params</code>","text":"<pre><code>print(request.path_params)\n\n# output:\n{\n     'id': 1\n}\n</code></pre>"},{"location":"reference/request/#requestroute","title":"<code>request.route</code>","text":"Info <p>This will provide the route with the path param variables included</p> <pre><code>print(request.route)\n\n# output:\n'grower/{id}'\n</code></pre>"},{"location":"reference/request/#requestpath","title":"<code>request.path</code>","text":"Info <p>This will provide the route with the path param values replacing the variables</p> <pre><code>print(request.path)\n\n# example output: \n'grower/1'\n</code></pre>"},{"location":"reference/request/#requestjson","title":"<code>request.json</code>","text":"Warning <p>This will raise an unhandled exception if the body is not json compatible</p> <pre><code>print(request.json);\n\n# output:\n{\n    'some_json_key': 'some_json_value'\n}\n</code></pre> <pre><code>print(request.form);\n\n# output:\n{\n    'some_form_key': 'some_form_value'\n}\n</code></pre>"},{"location":"reference/request/#requestxml","title":"<code>request.xml</code>","text":"Warning <p>This will raise an unhandled exception if the body is not xml compatible</p> <pre><code>python(request.xml);\n\n# output:\n{\n    'some_xml_key': 'some_xml_value'\n}\n</code></pre>"},{"location":"reference/request/#requestgraphql","title":"<code>request.graphql</code>","text":"Info <p>This is graphql string since there is no object equivalent; you can pass this directly to your graphql resolver</p> <pre><code>python(request.graphql);\n\n# output:\n'{\n    players {\n        name\n    }\n}'\n</code></pre>"},{"location":"reference/request/#requestbody","title":"<code>request.body</code>","text":"Tip <p>This is the safest way to get the body of the request. It will use the <code>content-type</code> header to determine the data sent and convert it; if the data can't be converted for whatever reason it will catch the error and return the raw body provided unconverted.</p> <pre><code>print(request.body)\n\n# output:\n{\n    'some_key': 'some_value'\n}\n</code></pre>"},{"location":"reference/request/#requestraw","title":"<code>request.raw</code>","text":"<pre><code>print(request.raw)\n\n# output: \n# whatever the raw data of the body is; string, json string, xml, binary, etc\n</code></pre>"},{"location":"reference/request/#requestcontext","title":"<code>request.context</code>","text":"Tip <p>This is the only mutable property of the request, to be used by any of the <code>before</code> or <code>before_all</code> middleware options</p> <pre><code>request.context = {'application_assignable': true}\nprint(request.context)\n\n# output:\n{\n    'application_assignable': true\n}\n</code></pre>"},{"location":"reference/response/","title":"Request Reference","text":"<p>By default, every endpoint function will receive an instance of the <code>Response</code> class (aka <code>response</code>) as the second argument of their function.  This response object is meant to provide consistency to HTTP response codes and error signatures. Below is a list and examples of all the properties of the <code>response</code>:</p>"},{"location":"reference/response/#response-properties","title":"Response Properties","text":"property type description <code>headers</code> tuple provide headers in tuple pairs to add new headers <code>code</code> int http response code to be returned the requester <code>body</code> any body of the response automatically converted to JSON string <code>raw</code> any body of the response not converted to JSON string <code>compress</code> bool will compress the body if set to true and add proper headers <code>set_error</code> func function to set an error with a key and value <code>has_error</code> boolean simple property to check if response already has errors in it"},{"location":"reference/response/#responseheaders","title":"<code>response.headers</code>","text":"<pre><code>response.headers = ('status', 'ok')\nresponse.headers = ('response_id', 'some-guid')\n\nprint(response.headers)\n\n# output:\n{\n    'status': 'ok',\n    'response_id': 'some-guid',\n}\n</code></pre>"},{"location":"reference/response/#responsecode","title":"<code>response.code</code>","text":"<pre><code>response.code = 418;\n\nprint(response.code);\n\n# output:\n418\n</code></pre>"},{"location":"reference/response/#responsebody","title":"<code>response.body</code>","text":"Info <p>This will automatically convert the body to json if possible when called.</p> <pre><code>response.body = {'some_key': 'some_value'}\n\nprint(response.body)\n\n# output:\n'{\"someKey\":\"someValue\"}'\n</code></pre>"},{"location":"reference/response/#responseraw","title":"<code>response.raw</code>","text":"Info <p>This will NOT automatically convert the body to json if possible when called. This is great when working with an <code>after_all</code> method that wants to mutate the body of the response before returning to the user.</p> <pre><code>response.raw = {'some_key': 'some_value'};\n\nprint(response.raw)\n\n# output:\n{\n    'some_key': 'some_value'\n}\n</code></pre>"},{"location":"reference/response/#responsecompress","title":"<code>response.compress</code>","text":"Info <p>This will compress whatever is in the body property.</p> <pre><code>response.compress = True\n\nprint(response.body)\n# output: this will gzip and compress the body.\n</code></pre>"},{"location":"reference/response/#responseset_errorkey-value","title":"<code>response.set_error(key, value)</code>","text":"<pre><code>some_key = 'abc123'\nresponse.set_error('someKey', f'{some_key} is not a valid key to use with this service; try again with a different key')\nanother_key = 'def456'\nresponse.set_error('anotherKey', f'{another_key} is not the correct type to operate on')\n\nprint(response.raw)\n\n# output:\n{\n    'errors': [\n        {\n            'key_path': 'someKey',\n            'message': 'abc123 is not a valid key to use with this service; try again with a different key'\n        },\n        {\n            'key_path': 'anotherKey',\n            'message': 'def456 is not the correct type to operate on'\n        }\n    ]\n}\n</code></pre>"},{"location":"reference/response/#responsehas_error","title":"<code>response.has_error</code>","text":"<pre><code>response.setError('user', 'your access is denied')\nprint(response.has_error)\n\n# output:\nTrue\n\n\nresponse.body = {'user': 'you have been granted access'};\nprint(response.has_error)\n\n# output:\nFalse\n</code></pre>"},{"location":"reference/router/","title":"Router Refernce","text":""},{"location":"reference/router/#configuration-options","title":"Configuration Options","text":"option type required description <code>after_all</code> func no will call this function after EVERY request to the API <code>base_path</code> str yes the base path of the API Gateway instance this is running on <code>before_all</code> func no will call this function before EVERY request to the API <code>cache_mode</code> str no; 'all','static-only','dynamic-only' will cache route endpoint module (not response), all, static, or dynamic (routes with path variables) endpoints <code>cache_size</code> int no; (default 128) how many endpoint modules to cache <code>cors</code> bool no (default True) will open cors to allow hitting from any source (<code>*</code>) <code>handlers</code> str yes file path pointing to the directory where the endpoints are <code>host</code> str no (default 127.0.0.1) host address to run on <code>on_error</code> func no will call this function on every unhandled error; not including validation errors <code>on_timeout</code> func no when timout error is raised, this function will run <code>openapi_validate_request</code> bool no; requires <code>schema</code> will automatically validate request against openapi.yml <code>openapi_validate_response</code> bool no will validate response of an endpoint, can effect performance, not recommended for production <code>output_error</code> bool no (default true) will output more detailed error from stacktrace as part of api response; otherwise will only say <code>internal server error</code> <code>port</code> int no (default 3000) will output more detailed error from stacktrace as part of api response; otherwise will only say <code>internal server error</code> <code>schema</code> str yes, if <code>openapi_validate_request</code> file path pointing to the location of the openapi.yml file <code>timeout</code> int no (default <code>None</code>) timeout functionality for main handler logic (does not indclude before, after, before_all, after_all) <code>verbose</code> bool no will log every setup, every request and every response <code>when_auth_required</code> func no will call this function when <code>requirements</code> decorator have <code>auth_required</code> set to <code>True</code>"},{"location":"reference/router/#example-code","title":"Example Code","text":"<pre><code>from chilo_api import Chilo\n\n\ndef before_all(request, response, requirements):\n    # will run before every request\n    pass\n\n\ndef afrer_all(request, response, requirements):\n    # will run after every request\n    pass\n\n\ndef when_auth_required(request, response, requirements):\n    # will run only when @requirements(auth_required=True)\n    pass\n\n\ndef on_error(request, response, requirements):\n    # will run on any 5xx level error\n    pass\n\n\ndef on_timeout(request, response, requirements):\n    # will run on any timeout error\n    pass\n\n\napi = Chilo(\n    host='127.0.0.1'\n    port=3000\n    base_path='/',\n    handlers='api/handlers',\n    schema='api/openapi.yml',\n    openapi_validate_request=True\n    openapi_validate_response=True\n    reload=True\n    verbose=True\n    before_all=before_all\n    after_all=afrer_all\n    when_auth_required=when_auth_required\n    on_error=on_error\n    on_timeout=on_timeout\n    cors=True\n    timeout=30\n    cache_size=128\n    cache_mode='all'\n)\n</code></pre>"}]}